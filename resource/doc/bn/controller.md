# নিয়ন্ত্রক

নতুন নিয়ন্ত্রক ফাইল তৈরি করুন `app/controller/FooController.php`।

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function index(Request $request)
    {
        return response('hello index');
    }
    
    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```

`http://127.0.0.1:8787/foo` এ অ্যাক্সেস করলে, পৃষ্ঠায় `hello index` প্রদর্শন করা হবে।

`http://127.0.0.1:8787/foo/hello` এ অ্যাক্সেস করলে, পৃষ্ঠায় `hello webman` প্রদর্শন করা হবে।

প্রাকস্যিকভাবে সামগ্রী নির্ধারণের জন্য রুটিং পুনর্নির্ধারণ করতে আপনি [রুট](route.md) দেখতে পারেন।

> **পরামর্শ**
> যদি 404 এরর সনাক্ত হয়, তবে `config/app.php` খোলে, `controller_suffix` কে `Controller` হিসেবে সেট করুন এবং পুনরায় আর্ম করুন। 

## নিয়ন্ত্রকের পরবর্তীত্ব
ওয়েবম্যান 1.3 সংস্করণ থেকে, `config/app.php` তে নিয়ন্ত্রক সাফিক্স সমর্থন করে, যদি `config/app.php` তে `controller_suffix` খালি `''` হয়, তবে নিয়ন্ত্রক প্রকার এমন হবে

`app\controller\Foo.php`।

```php
<?php
namespace app\controller;

use support\Request;

class Foo
{
    public function index(Request $request)
    {
        return response('hello index');
    }
    
    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```

নিশ্চিত করতে নোট করুন যে নিয়ন্ত্রকের সাফিক্স হিসেবে `Controller` সেট করা হারাম, যাতে নিয়ন্ত্রক এবং মডেল ক্লাসের নামের মাধ্যমে নাম আসুক এবং সাথে সার্কিউরিটি বাড়ানো যায়।

## বিস্তারিত
- প্রফ্রাম স্বয়ংক্রিয়ভাবে নিয়ন্ত্রকে সরবরাহ করা `support\Request` অবজেক্ট মাধ্যমে, যা দ্বারা ব্যবহারকারীর ইনপুট ডেটা (get post header cookie ইত্যাদি ডেটা) প্রাপ্ত করা যায়, দেখুন [অনুরোধ](request.md)
- নিয়ন্ত্রক থেকে সংখ্যা, স্ট্রিং, বা সাপোর্ট প্রতিক্রিয়া অবজেক্ট ফিরে দেওয়া যেতে পারে, কিন্তু অন্য ধরণের ডেটা ফিরে দেওয়া যাবে না।
- `support\Response` অবজেক্ট তৈরি করতে `response()` `json()` `xml()` `jsonp()` `redirect()` ইত্যাদি হেল্পার ফাংশন দ্বারা তৈরি করা যেতে পারে।

## নিয়ন্ত্রকের জীবনচক্র

যখন `config/app.php` তে `controller_reuse` সাধারণ হবে `false`, তখন প্রতিটি অনুরোধের জন্য প্রতিটি নিয়ন্ত্রক ইনস্ট্যান্সির পুনরায় শুরু হবে, অনুরোধ শেষে নিয়ন্ত্রক ইনস্ট্যান্সি ধ্বংস হবে এবং মেমোরি রিসাইকেল হবে। এটা প্রথাগত ফ্রেমওয়ার্কের মেকানিজমের সাথে মিল।

যখন `config/app.php` তে `controller_reuse` সত্যি থাকবে, তখন সমস্ত অনুরোধ নিয়ন্ত্রক ইনস্ট্যান্সের পুনর্ব্যবহার হবে, অর্থাৎ একবার নিয়ন্ত্রক ইনস্ট্যান্স তৈরি হলে নিয়ন্ত্রকটি অবলম্বন মেমোরিতে থাকবে এবং সমস্ত অনুরোধ ব্যবহার এর পর।

> **নোট**
> নিয়ন্ত্রক পুনরায় ব্যবহার বন্ধ হয় ওয়েবম্যান>=1.4.0 এবং এটা অর্থাৎ 1.4.0 এর পূর্বে নিয়ন্ত্রক চূড়ান্তভাবে সমস্ত অনুরোধ পুনরায় ব্যবহার হলে, পরিবর্তন করা যায় না।

> **নোট**
> কণ্ঠিত নিয়ন্ত্রক ব্যবহার হয়, অনুরোধে নিয়ন্ত্রকের কোনও বৈশিষ্ট্য পরিবর্তন করা উচিত নয়, কারণ এই পরিবর্তন গোলানূনের পরিবর্তন করবে। উদাহরণস্বরূপ

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    protected $model;
    
    public function update(Request $request, $id)
    {
        $model = $this->getModel($id);
        $model->update();
        return response('ok');
    }
    
    public function delete(Request $request, $id)
    {
        $model = $this->getModel($id);
        $model->delete();
        return response('ok');
    }
    
    protected function getModel($id)
    {
        // এই পদ্ধতির কারণে প্রথম অনুরোধ update?id=1 পরে মডেল সংরক্ষণ করা হবে।
        // আরো একবার অনুরোধ delete?id=2 এ, 1 এর উপাদানগুলি মুছে দেওয়া হবে
        if (!$this->model) {
            $this->model = Model::find($id);
        }
        return $this->model;
    }
}
```

> **পরামর্শ**
> নিয়ন্ত্রকে `__construct()` মেথডে `return` ডেটা কোনও প্রভাব ফেলবে না, উদাহরণস্বরূপ

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function __construct()
    {
        // নির্মাণকারী মেথডে `return` ডেটা কোনও প্রভাব ফেলবে না, ব্রাউজার এই সম্মতি প্রাপ্ত করবে না
        return response('hello'); 
    }
}
```

## নিয়ন্ত্রক পুনরায় ব্যবহার এবং ব্যবহারের পার্থক্য
পার্থক্যগুলি নিম্নলিখিত

#### নিয়ন্ত্রক পুনরায় ব্যবহার হলে
প্রতিটি অনুরোধের জন্য একটি নতুন নিয়ন্ত্রক ইনস্ট্যান্স পুনরায় শুরু হবে, অনুরোধ শেষে প্রত্যাহার এর প্রত্যাহার করা হবে এবং এর পরে মেমোরি ফ্রি হবে। নিয়ন্ত্রকের পুনরায় ব্যবহার এবং প্রথাগত ফ্রেমওয়ার্কের মধ্যে পার্থক্য। নিয়ন্ত্রক প্রাচীরভাবে তৈরি এবং ধ্বংসের জন্য বৃহদাকারের মিলন করে।

#### নিয়ন্ত্রক পুনরায় ব্যবহার করলে
প্রতিটি অনুরোধ একবার নিয়ন্ত্রক ইনস্ট্যান্স তৈরি করা হবে, অনুরোধ শেষে এই নিয়ন্ত্রক ইনস্ট্যান্স মুক্ত হবেনা, এবং বর্তমান প্রক্রিয়ায় অনুরোধ পুনর্ব্যবহার করবে। নিয়ন্ত্রণাধীন নিয়ন্ত্রক শুধুমাত্রা অধীনে পড়ে,কিন্তু প্রক্রিয়াবদ্ধকে নাও।

#### ২.15.1 ডেটাসেট ব্যবহারে অক্ষম এবং ব্যবহারে কোন পার্থক্য
নিয়ন্ত্রক হোলিস্ট্যাক

