# Контроллер

Создайте новый файл контроллера `app/controller/FooController.php`.

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function index(Request $request)
    {
        return response('hello index');
    }
    
    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```

При доступе к `http://127.0.0.1:8787/foo` отобразится `hello index`.

При доступе к `http://127.0.0.1:8787/foo/hello` отобразится `hello webman`.

Конечно, вы можете изменить правила маршрутизации с помощью конфигурации маршрутов, см. [Маршруты](route.md).

> **Совет**
> Если возникает ошибка 404 при доступе, откройте `config/app.php`, установите `controller_suffix` в значение `Controller` и перезапустите систему.

## Суффикс контроллера
Начиная с версии 1.3, webman поддерживает установку суффикса контроллера в файле `config/app.php`. Если значение `controller_suffix` в файле `config/app.php` установлено на пустую строку `''`, то контроллер будет выглядеть следующим образом:

`app\controller\Foo.php`.

```php
<?php
namespace app\controller;

use support\Request;

class Foo
{
    public function index(Request $request)
    {
        return response('hello index');
    }
    
    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```

Мы настоятельно рекомендуем установить суффикс контроллера как `Controller`, чтобы избежать конфликта имен контроллера и модели, а также повысить безопасность.

## Пояснение
- Фреймворк автоматически передает в контроллер объект `support\Request`, через который можно получить данные пользователя (данные get, post, заголовок, cookie и другие), см. [Запросы](request.md).
- В контроллере можно возвращать числа, строки или объект типа `support\Response`, но нельзя возвращать другие типы данных.
- Объект типа `support\Response` можно создать с помощью вспомогательных функций, таких как `response()`, `json()`, `xml()`, `jsonp()`, `redirect()` и другие.

## Жизненный цикл контроллера

Когда в файле `config/app.php` параметр `controller_reuse` установлен в `false`, каждый запрос инициализирует экземпляр соответствующего контроллера, после завершения запроса экземпляр контроллера уничтожается, что аналогично традиционному механизму работы фреймворка.

Когда в файле `config/app.php` параметр `controller_reuse` установлен в `true`, все запросы будут использовать один экземпляр контроллера, то есть экземпляр контроллера остается в памяти после создания и используется для всех последующих запросов.

> **Обратите внимание**
> Для отключения повторного использования контроллеров требуется webman>=1.4.0, то есть по умолчанию до версии 1.4.0 контроллеры всегда повторно использовались и это нельзя было изменить.

> **Обратите внимание**
> При включении повторного использования контроллеров запросы не должны изменять свойства контроллера, потому что эти изменения повлияют на последующие запросы. Например,

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    protected $model;
    
    public function update(Request $request, $id)
    {
        $model = $this->getModel($id);
        $model->update();
        return response('ok');
    }
    
    public function delete(Request $request, $id)
    {
        $model = $this->getModel($id);
        $model->delete();
        return response('ok');
    }
    
    protected function getModel($id)
    {
        // Этот метод сохранит модель после первого запроса update?id=1
        // Если запросить delete?id=2, то будет удалена запись с id=1
        if (!$this->model) {
            $this->model = Model::find($id);
        }
        return $this->model;
    }
}
```

> **Совет**
> В конструкторе `__construct()` контроллера возвращаемое значение не будет иметь никакого эффекта, например

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function __construct()
    {
        // Возвращаемое значение в конструкторе не будет иметь никакого эффекта, браузер не получит это в ответ
        return response('hello'); 
    }
}
```

## Различия между повторным использованием и неповторным использованием контроллера
Различия заключаются в следующем:

#### Неповторное использование контроллера
При каждом запросе создается новый экземпляр контроллера, после завершения запроса этот экземпляр удаляется и память освобождается. Неповторное использование контроллеров аналогично традиционному фреймворку и соответствует привычкам большинства разработчиков. Из-за повторного создания и удаления контроллеров производительность немного хуже, чем у повторного использования контроллеров (производительность в тесте helloworld ухудшается на 10% примерно, в настоящем бизнесе это можно игнорировать).

#### Повторное использование контроллера
При повторном использовании контроллера каждый процесс создает экземпляр контроллера только один раз, после завершения запроса этот экземпляр контроллера не удаляется, а используется для всех последующих запросов этого процесса. Повторное использование контроллера обеспечивает лучшую производительность, но не соответствует привычкам большинства разработчиков.

#### Ситуации, когда нельзя использовать повторное использование контроллера
Нельзя включать повторное использование контроллеров, когда запросы изменяют свойства контроллера, потому что эти изменения влияют на последующие запросы.

Некоторые разработчики любят проводить инициализацию для каждого запроса в конструкторе контроллера `__construct()`. В таких случаях нельзя использовать повторное использование контроллера, потому что конструктор процесса вызывается только один раз и не вызывается для каждого запроса.
