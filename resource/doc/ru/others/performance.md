# Производительность webman

### Процесс обработки запросов традиционного фреймворка

1. Nginx/Apache получает запрос
2. Nginx/Apache передает запрос в php-fpm
3. PHP-FPM инициализирует среду, такую как создание списка переменных
4. PHP-FPM вызывает RINIT различных расширений/модулей
5. PHP-FPM считывает PHP-файл с диска (использование opcache может избежать этого)
6. PHP-FPM проводит лексический анализ, синтаксический анализ, компиляцию в opcode (использование opcache может избежать этого)
7. PHP-FPM выполняет opcode, включая 8, 9, 10, 11
8. Инициализация фреймворка, такая как создание экземпляров различных классов, включая контейнер, контроллеры, маршруты, промежуточное ПО и т. д.
9. Фреймворк подключается к базе данных, выполняет проверку прав доступа, подключается к Redis
10. Фреймворк выполняет бизнес-логику
11. Фреймворк закрывает подключения к базе данных и к Redis
12. PHP-FPM освобождает ресурсы, уничтожает все определения классов, экземпляры, уничтожает таблицу символов и т. д.
13. PHP-FPM последовательно вызывает методы RSHUTDOWN различных расширений/модулей
14. PHP-FPM перенаправляет результат Nginx/Apache
15. Nginx/Apache возвращает результат клиенту

### Процесс обработки запросов webman
1. Фреймворк получает запрос
2. Фреймфорк выполняет бизнес-логику
3. Фреймворк возвращает результат клиенту

Да, без обратного прокси Nginx, у фреймворка всего лишь 3 шага. Можно сказать, что это уже предельно для фреймворка на PHP, что делает производительность webman в несколько раз и даже десятки раз выше, чем у традиционных фреймворков.

Дополнительная информация доступна в [тестах производительности](benchmarks.md)
