# دورة حياة

## دورة حياة العملية
- كل عملية لديها دورة حياة طويلة جدًا
- كل عملية تعمل بشكل مستقل ومن دون تداخل
- يمكن لكل عملية في دورة حياتها معالجة العديد من الطلبات
- تقوم العملية بالخروج وإنهاء دورتها الحياتية عند تلقي أوامر "stop"، "reload"، "restart"

> **نصيحة**
> كل عملية مستقلة ومتقاطعة، مما يعني أن كل عملية تحافظ على مواردها ومتغيراتها وحالات فئتها الخاصة، وهذا يعني أن كل عملية لديها اتصال قاعدة بيانات خاص بها، وبعض الفئات الفردية تبدأ مرة واحدة لكل عملية، وبالتالي ستبدأ مرات عديدة لعدة عمليات.

## دورة حياة الطلب
- كل طلب يؤدي إلى إنشاء كائن `$request`
- يتم استرداد كائن `$request` بعد اكتمال معالجة الطلب

## دورة حياة المراقب
- يتم إنشاء مثيل واحد فقط لكل مراقب في كل عملية، وهو ما يعني أنه يتم إنشاءه مرات عديدة في عمليات متعددة (باستثناء اغلاق اعادة استخدام المراقب، انظر [دورة حياة المراقب](https://www.workerman.net/doc/webman/controller.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F))
- يتم مشاركة مثيل المراقب بين العديد من الطلبات في نطاق العملية الحالية (باستثناء اغلاق اعادة استخدام المراقب)
- تنتهي دورة حياة المراقب بعد خروج العملية (باستثناء اغلاق اعادة استخدام المراقب)

## بشأن دورة حياة المتغيرات
تعتمد webman على PHP، لذا فهو يتبع تمامًا آلية إعادة استرداد المتغيرات في PHP. يتم إعادة استرداد المتغيرات المؤقتة التي تم إنشاؤها داخل العمليات التجارية، بما في ذلك مثيلات الفئات التي تم إنشاؤها باستخدام الكلمة الرئيسية `new`، بمجرد انتهاء الدالة أو الطريقة، دون الحاجة إلى استدعاء `unset` يدويًا. وبمعنى آخر، تجربة تطوير webman متماثلة تمامًا لتجربة تطوير الأطر القياسية. على سبيل المثال، سيتم إطلاق سراح مثيل `$foo` تلقائيًا بمجرد اكتمال تنفيذ الدالة index:
```php
<?php

namespace app\controller;

use app\service\Foo;
use support\Request;

class IndexController
{
    public function index(Request $request)
    {
        $foo = new Foo(); // نفترض هنا وجود فئة Foo
        return response($foo->sayHello());
    }
}
```
إذا كنت ترغب في إعادة استخدام مثيل لفئة معينة، يمكنك حفظ الفئة داخل خاصية ساكنة للفئة أو داخل خاصية الكائن ذي الدورة الحياة الطويلة (مثل المراقب)، أو يمكنك استخدام طريقة `Container` لإنشاء مثيل الفئة، على سبيل المثال:
```php
<?php

namespace app\controller;

use app\service\Foo;
use support\Container;
use support\Request;

class IndexController
{
    public function index(Request $request)
    {
        $foo = Container::get(Foo::class);
        return response($foo->sayHello());
    }
}
```
تستخدم طريقة `Container::get()` لإنشاء وحفظ مثيل الفئة، وسيتم إرجاع مثيل الفئة الذي تم إنشاؤه سابقًا عند استدعاء الطريقة مرة أخرى باستخدام نفس المعلمات.

> **ملاحظة**
> `Container::get()` قادرة فقط على إنشاء مثيلات بدون معلمات البناء. `Container::make()` قادرة على إنشاء مثيلات تحتوي على معلمات بناء، ولكن الاختلاف الرئيسي بين `Container::make()` و`Container::get()` هو أن `Container::make()` لن تعيد استخدام المثيلات، مما يعني أنها ستعيد دائمًا مثيلًا جديدًا حتى عند استدعاءها بنفس المعلمات.

# بشأن تسرب الذاكرة
في معظم الحالات، لن يحدث تسرب الذاكرة في رمز الأعمال الخاص بك (قليل جدًا ممن يلاحظون حدوث تسرب الذاكرة). كل ما عليك فعله هو الانتباه قليلاً للبيانات الطويلة الدورة الحياة وعدم توسيعها بشكل لا نهائي. يرجى الاطلاع على الشفرة التالية كمثال:
```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    // خاصية القائمة
    public $data = [];
    
    public function index(Request $request)
    {
        $this->data[] = time();
        return response('مرحباً، كماي');
    }

    public function hello(Request $request)
    {
        return response('مرحبًا بكم في ويبمان');
    }
}
```
المراقب هو، عادة، لديه دورة حياة طويلة (باستثناء اغلاق اعادة استخدام المراقب)، وبالمثل، خاصية القائمة `$data` في المراقب هي ذات دورة حياة طويلة، ومع استمرار طلب `foo/index`، يتزايد عدد العناصر في `$data` مما يؤدي إلى تسرب الذاكرة.

يرجى الرجوع للمزيد من المعلومات عن [تسرب الذاكرة](./memory-leak.md)
