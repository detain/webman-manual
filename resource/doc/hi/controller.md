# नियंत्रक

नया नियंत्रक फ़ाइल `app/controller/FooController.php` बनाएं।

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function index(Request $request)
    {
        return response('hello index');
    }
    
    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```

`http://127.0.0.1:8787/foo` पर जब पहुंचते हैं, पेज `hello index` लौटाती है।

`http://127.0.0.1:8787/foo/hello` पर जब जाते हैं, पेज `hello webman` लौटाती है।

और अगर आप रूटिंग सेटिंग के माध्यम से रूटिंग नियमों को बदलना चाहते हैं तो, [रूटिंग](route.md) देखें।

> **सुझाव**
> अगर 404 त्रुटि होती है, तो `config/app.php` खोलें, और `controller_suffix` को `Controller` के रूप में सेट करें, और पुनः आरंभ करें।

## नियंत्रक प्रत्यय

वेबमैन 1.3 संस्करण से आगे, `config/app.php` में नियंत्रक प्रत्यय को सेट करने का समर्थन है, अगर `config/app.php` में `controller_suffix` को खाली `''` सेट किया जाता है, तो नियंत्रक जैसा कि निम्नलिखित है

`app\controller\Foo.php`।

```php
<?php
namespace app\controller;

use support\Request;

class Foo
{
    public function index(Request $request)
    {
        return response('hello index');
    }
    
    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```

सख्त रूप से नियंत्रक प्रत्यय को `Controller` के रूप में सेट करने की सलाह दी जाती है, इससे नियंत्रक और मॉडल कक्षाएँ के नाम संरेखित होते हैं, साथ ही सुरक्षा बढ़ती है।

## स्पष्टीकरण
 - फ़्रेमवर्क स्वचालित रूप से नियंत्रक को `support\Request` ऑब्जेक्ट पहुंचाता है, जिसके माध्यम से उपयोक्ता इनपुट डेटा (गेट पोस्ट हेडर कुकी आदि डेटा) प्राप्त कर सकता है, [अनुरोध](request.md) देखें
 - नियंत्रक में संख्या, स्ट्रिंग या `support\Response` ऑब्जेक्ट लौटा सकता है, लेकिन अन्य प्रकार के डेटा नहीं लौटा सकता है।
 - `support\Response` ऑब्जेक्ट `response()`, `json()`, `xml()`, `jsonp()`, `redirect()` आदि सहायक फ़ंक्शन के माध्यम से बनाया जा सकता है।

## नियंत्रक जीवनकाल
 `config/app.php` में `controller_reuse` जब `false` होता है, तो प्रत्येक अनुरोध अपने समर्थन में नियंत्रक नमूने का नवीनीकरण करेगा, अनुरोध समाप्त होने के बाद नियंत्रक नमूने को 'मार देगा', यह पारंपरिक ढंग से कार्य करने वाले फ़्रेमवर्क के तरह है।

 `config/app.php` में `controller_reuse` जब `true` होता है, तब सभी अनुरोध निन्मित नियंत्रक नमूने को पुनर्चक्रण करेंगे, अर्थात नियंत्रक नमूने एक बार नमूना बनाने के बाद मेमोरी में सन्चित रहेगा, सभी अनुरोध नमूने फिर से उपयोग करेंगे।

> **ध्यान दें**
> नियंत्रक पुनर्चक्रण को बंद करने के लिए webman>=1.4.0 की आवश्यकता है, अर्थात 1.4.0 से पहले नियंत्रक को डिफ़ॉल्ट रूप से सभी अनुरोध पुनर्चक्रणीय हैं, और इसे बदला नहीं जा सकता है।

> **ध्यान दें**
> नियंत्रक पुनर्चक्रण को खोलने पर, अनुरोध कोई नियंत्रक गुणसूचक परिवर्तित करते समय, क्योंकि इन परिवर्तनों से आगे के अनुरोध प्रभावित होंगे।

कुछ विकसितकर्ता नियंत्रक नामकरण फ़्कस्त `__construct()` में हर अनुरोध के लिए कुछ प्रारंभिकण करना चाहते हैं, इस स्थिति में नियंत्रक पुनर्चक्रण नहीं किया जा सकता, क्योंकि वर्तमान प्रक्रिया में केवल एक बार कार्य संचालन होगा, और हर अनुरोध के लिए नहीं।

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    protected $model;

    public function update(Request $request, $id)
    {
        $model = $this->getModel($id);
        $model->update();
        return response('ok');
    }
    
    public function delete(Request $request, $id)
    {
        $model = $this->getModel($id);
        $model->delete();
        return response('ok');
    }
    
    protected function getModel($id)
    {
        // इस विधि को पहले के अनुरोध update?id=1 के बाद मॉडल को संरक्षित करेगी
        // अगर फिर से नियंत्रक नमूना delete?id=2 को अनुरोध किया गया है, तो 1 को डेटा हटा दिया जाएगा।
        if (!$this->model) {
            $this->model = Model::find($id);
        }
        return $this->model;
    }
}
```

> **सुझाव**
> नियंत्रक `__construct()` फ़ंक्शन में डेटा लौटाना कोई प्रभाव नहीं डालेगा, उदाहरण के लिए

```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function __construct()
    {
        // निर्माण फ़ंक्शन में डेटा लौटाने का कोई प्रभाव नहीं होगा, ब्राउज़र इस प्रतिक्रिया को प्राप्त नहीं करेगा
        return response('hello'); 
    }
}
```

## नियंत्रक पुनर्चक्रण और पुराने में अंतर
इसके पुराने और पुराने में अंतर इस प्रकार है

#### पुराने नियंत्रक
प्रत्येक अनुरोध के लिए एक नया नियंत्रक नमूना बनाया जाएगा, अनुरोध समाप्त होने के बाद यह नियंत्रक नमूना मुक्त किया जाएगा और मेमोरी संचय किया जाएगा। नियंत्रक पुराने के साथ भी बेहद कमजोर (helloworld दबाव-परीक्षण प्रदर्शन 10% लगभग कमजोर, व्यापार सहित लगभग इसे नजरानुहार परिगणित कर सकते हैं)।

#### नियंत्रक पुनर्चक्रण
यदि एक प्रक्रिया नियंत्रक एक बार बनाती है तो, अनुरोध समाप्त होने के बाद यह नियंत्रक मूर्ति नहीं करती है, तो मौजूद प्रक्रिया के उपयोगकर्ता इस मूर्ति का उपयोग करेंगे। नियंत्रक पुनर्चक्रण की प्रदर्शन अधिक बेहतर होती है, लेकिन इसकी कुलता के बहुत कम लोग अनुभव कर पाते हैं।

#### नियंत्रक पुनर्चक्रण के निषेध मामले

जब अनुरोध नियंत्रक के गुणसूचकों को परिवर्तित करता है, तो नियंत्रक पुनर्चक्रण नहीं कर सकते, क्योंकि इन परिवर्तनों के बाद उपकारिता प्रभावित होगी।

कुछ विकसितकर्ता नियंत्रक `__construct()` फ़ंक्शन में हर अनुरोध के लिए कुछ प्रारंभिकण करना पसंद करते हैं, तो इस गतिविधि में नियंत्रक पुनर्चक्रण नहीं किया जा सकता, क्योंकि मौजूद प्रक्रिया में `__construct()` सिर्फ एक बार बुलाया जाएगा, और हर अनुरोध के लिए नहीं।
