# व्यावसायिक प्रारंभ

कभी-कभी हमें प्रक्रिया के बाद कुछ व्यावसायिक प्रारंभ करने की आवश्यकता होती है, यह प्रारंभ प्रक्रिया के जीवनकाल में केवल एक बार होती है, जैसे प्रक्रिया शुरू होने के बाद एक टाइमर सेट करना, या डेटाबेस कनेक्शन की प्रारंभिकीकरण आदि। नीचे हम इसका विवरण देंगे।

## सिद्धांत
**[प्रोसेस](process.md)** में बताए गए सिद्धांत के अनुसार, webman प्रक्रिया शुरू होने के बाद `config/bootstrap.php` (इसमें `config/plugin/*/*/bootstrap.php` भी शामिल है) में सेट किए गए कक्षाओं को लोड करता है और कक्षाओं का start मेथड चलाता है। हम start मेथड में व्यावसायिक कोड जोड़ सकते हैं, जिससे प्रक्रिया शुरू होने के बाद व्यवसायिक प्रारंभ कार्य समाप्त हो जाएगा।

## प्रक्रिया
मान लीजिए हमें एक टाइमर बनाना है, जो वर्तमान प्रक्रिया के मेमोरी उपयोग की समय-समय पर रिपोर्ट करता है, इस कक्षा का नाम `MemReport` है।

#### कमांड चलाएं

कमांड `php webman make:bootstrap MemReport` चलाएं और शुरू करने के लिए `app/bootstrap/MemReport.php` नामक प्रारंभ फ़ाइल बनाएँ।

> **संकेत**
> यदि आपके पास webman/console इंस्टॉल नहीं है, तो कमांड `composer require webman/console` चलाकर इंस्टॉल करें।

#### प्रारंभ फ़ाइल संपादित करें
`app/bootstrap/MemReport.php` को संपादित करें और निम्नलिखित तरह का सामग्री डालें:
```php
<?php

namespace app\bootstrap;

use Webman\Bootstrap;

class MemReport implements Bootstrap
{
    public static function start($worker)
    {
        // क्या यह कमांड लाइन माहौल है?
        $is_console = !$worker;
        if ($is_console) {
            // यदि आप नहीं चाहते कि आपकी यह प्रारंभिकरण कमांड लाइन माहौल में चले, तो यहां सीधे वापस लौटें
            return;
        }
        
        // हर 10 सेकंड में चलाएं
        \Workerman\Timer::add(10, function () {
            // प्रदर्शन की सुविधा के लिए, यहां प्रतिबिंबन प्रक्रिया के बजाय उपयोग किया गया है
            echo memory_get_usage() . "\n";
        });
        
    }

}
```

> **संकेत**
> कमांड लाइन का उपयोग करते समय, अगर फ़्रेमवर्क ने `config/bootstrap.php` में सेट किए गए start मेथड को भी चलाया, तो हम `$worker` के द्वारा यह निर्णय ले सकते हैं कि क्या यह कमांड लाइन माहौल है और फिर उसके आधार पर व्यावसायिक प्रारंभ कोड को चलाने का निर्णय ले सकते हैं।

#### प्रक्रिया के साथ विन्यास
`config/bootstrap.php` खोलें और `MemReport` कक्षा को शुरू आइटम में जोड़ें।
```php
return [
    // ...अन्य विन्यास यहाँ पर छोड़े गए हैं...
    
    app\bootstrap\MemReport::class,
];
```

इस तरह से हमने एक व्यावसायिक प्रारंभ प्रक्रिया पूरी कर ली है।

## अतिरिक्त स्पष्टीकरण
[कस्टम प्रक्रिया](../process.md) के बाद भी `config/bootstrap.php` वाले start मेथड को चलाया जाएगा, हम `$worker->name` का उपयोग करके निर्धारित कर सकते हैं कि वर्तमान प्रक्रिया कौन सी है और फिर उस प्रक्रिया में अपने व्यावसायिक प्रारंभ कोड को क्या निर्धारित करना है, उदाहरण के लिए, हमें मॉनिटर प्रक्रिया का निगरानी करने की आवश्यकता नहीं है, तो `MemReport.php` की सामग्री निम्नलिखित तरह होगी:
```php
<?php

namespace app\bootstrap;

use Webman\Bootstrap;

class MemReport implements Bootstrap
{
    public static function start($worker)
    {
        // क्या यह कमांड लाइन माहौल है?
        $is_console = !$worker;
        if ($is_console) {
            // यदि आप नहीं चाहते कि आपकी यह प्रारंभिकरण कमांड लाइन माहौल में चले, तो यहां सीधे वापस लौटें
            return;
        }
        
        // मॉनिटर प्रक्रिया ने टाइमर नहीं चलाना है
        if ($worker->name == 'monitor') {
            return;
        }
        
        // हर 10 सेकंड में चलाएं
        \Workerman\Timer::add(10, function () {
            // प्रदर्शन की सुविधा के लिए, यहां प्रतिबिंबन प्रक्रिया के बजाय उपयोग किया गया है
            echo memory_get_usage() . "\n";
        });
        
    }

}
```
