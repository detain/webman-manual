# जीवनकाल (Lifecycle)
## प्रक्रिया का जीवनकाल
- प्रत्येक प्रक्रिया का बहुत लंबा जीवनकाल होता है
- प्रत्येक प्रक्रिया अलग-अलग रूप से स्वतंत्र रूप से चलती है
- प्रत्येक प्रक्रिया अपने जीवनकाल के दौरान कई अनुरोधों को संभाल सकती है
- प्रक्रिया `stop` `reload` `restart` आदेश प्राप्त करने पर बाहर निकलती है, इस जीवनकाल को समाप्त करती है।

> **टिप्पणी:**
> प्रत्येक प्रक्रिया स्वतंत्र होती है, इसका मतलब है कि प्रत्येक प्रक्रिया अपने आप के संसाधन, चर और कक्ष उदाहरण आदि की रखरखाव करती है, इसका अर्थ है कि प्रत्येक प्रक्रिया का अपना डेटाबेस कनेक्शन होता है, कुछ एकल उदाहरण प्रत्येक प्रक्रिया में केवल एक बार प्रारंभ होता है, तो ऐसा करने से कई प्रक्रियाएँ कई बार प्रारंभ हो जाएंगी।
## अनुरोध जीवनकाल
- प्रत्येक अनुरोध से एक `$request` ऑब्जेक्ट उत्पन्न होगा
- `$request` ऑब्जेक्ट को अनुरोध के प्रसंस्करण के बाद संग्रहीत किया जाएगा
## नियंत्रक जीवनकाल
- प्रत्येक नियंत्रक प्रत्येक प्रक्रिया में केवल एक बार नमूना बनाता है, एकाधिक प्रक्रियाओं में एकाधिक बार बनाया जाता है (नियंत्रक पुनर्प्रयोग समाप्त करने के अलावा, [नियंत्रक जीवनकाल](https://www.workerman.net/doc/webman/controller.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F) देखें)
- नियंत्रक नमूना मौजूदा प्रक्रिया में साझा किया जाएगा(नियंत्रक पुनर्प्रयोग समाप्त करने के अलावा)
- नियंत्रक जीवनकाल प्रक्रिया बंद होने के बाद समाप्त होता है (नियंत्रक पुनर्प्रयोग समाप्त करने के अलावा)
## चर जीवन के बारे में
webman PHP पर आधारित है, इसलिए यह पूरी तरह से PHP के चर रिसाइकलिंग मेकेनिज़्म का पालन करता है। व्यावसायिक तरीके से पैदा हुए अस्थायी चर शामिल हैं न्यू कीवर्ड से बनाई गई कक्षा के उदाहरण, फ़ंक्शन या विधि के समाप्त होने के बाद स्वचालित रूप से रिसायकल हो जाते हैं, उन्हें मैन्युअली `unset` से छोड़ देने की जरूरत नहीं होती। इसका अर्थ है कि webman विकास और पारंपरिक फ़्रेमवर्क विकास अनुभव आम तौर पर मेल खाते हैं। उदाहरण के रूप में नीचे दिए गए उदाहरण में, `$foo` उदाहरण index मेथड के पूरा होने के साथ स्वचालित रूप से रिसायकल हो जाएगा:

```php
<?php

namespace app\controller;

use app\service\Foo;
use support\Request;

class IndexController
{
    public function index(Request $request)
    {
        $foo = new Foo(); // यहाँ पर मान लें कि एक Foo क्लास है
        return response($foo->sayHello());
    }
}
```

यदि आप किसी कक्षा के एक उदाहरण का पुनर्ग्रहण करना चाहते हैं, तो आप कक्षा को कक्षा के स्थायी गुण में सहेज सकते हैं या लंबे जीवनकाल वाले ऑब्जेक्ट (जैसे कंट्रोलर) के गुण में सहेज सकते हैं, आप कंटेनर कंटेनर के `get` मेथड का उपयोग करके कक्षा के एक उदाहरण का आरंभ कर सकते हैं, उदाहरण के लिए:


```php
<?php

namespace app\controller;

use app\service\Foo;
use support\Container;
use support\Request;

class IndexController
{
    public function index(Request $request)
    {
        $foo = Container::get(Foo::class);
        return response($foo->sayHello());
    }
}
```

`Container::get()` विधि का उपयोग क्लास की नमूना बनाने और सहेजने के लिए किया जाता है, अगली बार जब एक ही पैरामीटर के साथ फिर से कॉल किया जाता है तो पहले से बनाए गए क्लास नमूने को लौटाएगा।


> **ध्यान दें**
> `Container::get()` केवल बिना किसी निर्माण पैरामीटर के इंस्टेंस को आरंभ कर सकता है। `Container::make()` किसी निर्माण तंत्र पैरामीटर के साथ इंस्टेंस बना सकता है, लेकिन `Container::get()` के विपरीत, `Container::make()` इंस्टेंस को पुनः उपयोग नहीं करता है, अर्थात यह यहां तक कि समान पैरामीटर के साथ `Container::make()` हमेशा एक नया इंस्टेंस लौटाता है।
## मेमोरी लीक के बारे में
अक्सर, हमारे व्यवसायिक कोड में मेमोरी लीक नहीं होती है (बहुत कम उपयोगकर्ता ने मेमोरी लीक की शिकायत की है), हमें बस ध्यान देने की जरूरत होती है कि लंबे समय तक रहने वाले एरे डेटा का अनंत फैलाव नहीं होना चाहिए। नीचे दिए गए कोड को देखें:
```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    // एरे प्रॉपर्टी
    public $data = [];
    
    public function index(Request $request)
    {
        $this->data[] = time();
        return response('hello index');
    }

    public function hello(Request $request)
    {
        return response('hello webman');
    }
}
```

नियंत्रक डिफ़ॉल्ट रूप से लंबे समय तक जीवनकालिक होता है (नियंत्रक पुन: प्रयोग को बंद कर देने को छोड़कर), समान रूप से नियंत्रक का `$data` अर्रे भी लंबे समय तक रहता है, `foo/index` अनुरोध के साथ साथ, `$data` अर्रे के तत्व बढ़ते जाएँगे, जिससे मेमोरी लीक हो जाएगा।

और अधिक संबंधित जानकारी के लिए कृपया [मेमोरी लीक](./memory-leak.md) देखें।
