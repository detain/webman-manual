याद रखें कि webman एक मेमोरी में रहने वाला फ्रेमवर्क है, इसलिए हमें मेमोरी लीकेज के मामले को थोड़ा ध्यान देना चाहिए। हालांकि डेवलपरों को ज्यादा चिंता करने की आवश्यकता नहीं है, क्योंकि मेमोरी लीकेज बहुत ही निर्धारित स्थितियों में होती है, और सुलझाने में बहुत आसान होती है। webman विकास और पारंपरिक फ्रेमवर्क विकास अनुभव में आंतरिक मेमोरी प्रबंधन के लिए कोई अतिरिक्त कार्य करने की आवश्यकता नहीं है।

> **सुझाव**
> webman में शामिल monitor प्रक्रिया सभी प्रक्रियाओं की मेमोरी उपयोग स्थिति का निगरानी करेगी, अगर प्रक्रिया मेमोरी उपयोग लगभग php.ini में `memory_limit` निर्धारित मान तक पहुंचने वाली है, तो वह स्वचालित रूप से संबंधित प्रक्रिया को सुरक्षित रीस्टार्ट करती है, जिससे मेमोरी मुक्ति होती है, इस दौरान व्यापार पर कोई प्रभाव नहीं होता।

## मेमोरी लीकेज की परिभाषा
निवेदन के साथ साथ, webman के संदर्भ में मेमोरी जगह **असीमित रूप से बढ़ती है** (ध्यान दें कि **असीमित रूप से बढ़ना** है), और कई सैंड्रिटों मेमोरी जगह कई सैंड्रिटों तक पहुँच सकती है, यह मेमोरी लीक है। यदि मेमोरी वृद्धि हुई है, लेकिन अंत में वृद्धि नहीं हुई है, तो यह मेमोरी लीक नहीं है।

सामान्य रूप से प्रक्रिया कुछ हर कई सैंड्रिटों की मेमोरी जगह संभालना सामान्य है, जब प्रक्रिया बड़े निवेदन का सामना करती है या बहुत सारे कनेक्शन को संभालने की कामना करती है, तो एक एकल प्रक्रिया की मेमोरी उपयोग संभावना है कि सैंड्रिट पर सैंड्रिट ज्यादा हो जाए, लेकिन पीएचपी यह सभी ऑपरेटिंग सिस्टम को पूरी तरह से वापस नहीं करता है। बल्कि पुन: इसे छोड़े रहता है, इसलिए संभावना है कि किसी महान निवेदन के समाधान के बाद मेमोरी जगह बढ़ सकती है, और मेमोरी जगह रिलीज नहीं होती है, यह सामान्य घटना है। (gc_mem_caches() मेथड को कॉल करने से कुछ खाली मेमोरी रिलीज हो सकती है)

## मेमोरी लीकेज कैसे होती है
**मेमोरी लीकेज होने के लिए निम्न दो स्थितियों को पूरा करना चाहिए:**
1. मौजूद होना **लंबे जीवनचक्र** के एरे (नोट करें कि यह **लंबे जीवनचक्र** के एरे है, साधारण एरे से बात नहीं है)
2. और इस **लंबे जीवनचक्र** के एरे की **असीमित वृद्धि** (व्यावसायिक असीमित रूप से इसे देखना, इसे ध्यान से पढ़ें)

यदि 1 और 2 शर्त **साथ आती** हैं, तो मेमोरी लीक होगी। उल्टे यह शर्तों को पूरा नहीं करता है या फिर सिर्फ एक शर्त को पूरा करता है, तो यह मेमोरी लीक नहीं है।

## लंबे जीवनचक्र के एरे
webman में लंबे जीवनचक्र के एरे निम्नलिखित हैं:
1. स्टैटिक कीवर्ड वाले एरे
2. सिंगल्टन के एरे प्रॉपर्टी
3. ग्लोबल कीवर्ड वाले एरे

> **ध्यान दें**
> webman में लंबे जीवनचक्र डेटा का उपयोग करने की अनुमति है, लेकिन यह सुनिश्चित करना चाहिए कि डेटा में उपलब्ध डेटा सीमित है, महाशयों की कोई संख्या बढ़ाने के लिए।

निम्नलिखित उदाहरणों को स्पष्ट करने के लिए

#### असीमित फैलता hोने वाले स्टैटिक कीवर्ड वाले एरे
```php
class Foo
{
    public static $data = [];
    public function index(Request $request)
    {
        self::$data[] = time();
        return response('hello');
    }
}
```

`static` कीवर्ड से डेफाइन किए गए `$data` एरे लंबे जीवनचक्र के एरे हैं, और उदाहरण में `$data` एरे तार ठीक लाने के साथ साथ निरंतर बढ़ते जाते हैं, जिससे मेमोरी लीक होती है।

#### असीमित फैलता hोने वाले सिंगल्टन के एरे प्रॉपर्टी
```php
class Cache
{
    protected static $instance;
    public $data = [];
    
    public function instance()
    {
        if (!self::$instance) {
            self::$instance = new self;
        }
        return self::$instance;
    }
    
    public function set($key, $value)
    {
        $this->data[$key] = $value;
    }
}
```

कॉल कोड
```php
class Foo
{
    public function index(Request $request)
    {
        Cache::instance()->set(time(), time());
        return response('hello');
    }
}
```

`Cache::instance()` कोड एक Cache सिंगल्टन वापस करता है, वह एक लंबे जीवनचक्र का वर्ग उपस्थित है, हालांकि इसके `$data` प्रॉपर्टी के बावजूद की वह `static` कीवर्ड का उपयोग नहीं किया गया है, लेकिन क्योंकि क्लास खुद एक लंबे जीवनचक्र का है, इसलिए `$data` भी लंबे जीवनचक्र के एरे हैं। अनेक वक्त `$data` एरे में विभिन्न कुंजी डेटा जोड़ते हुए, प्रोग्राम के मेमोरी उपयोग भी बढ़ता जाता है, मेमोरी लीक की स्थिति उत्पन्न होती है।

> **ध्यान दें**
> यदि Cache::instance()->set(key, value) जोड़े गए कुंजी सीमित मात्रा में होती है, तो मेमोरी लीक नहीं होगी, क्योंकि `$data` एरे असीमित फैलता नहीं है।

#### असीमित फैलता होने वाले ग्लोबल एरे
```php
class Index
{
    public function index(Request $request)
    {
        global $data;
        $data[] = time();
        return response($foo->sayHello());
    }
}
```
विशेषक कीवर्ड से परिभाषित एरे तब तक कि फ़ंक्शन या कक्षा पूर्ण होने के बाद संग्रहीत नहीं होते हैं, इसलिए यह लंबे जीवनचक्र के एरे हैं, यह ऊपर विन्यास के साथ प्रारम्भत hोते हैं और अनेक संबंधित परिप्रेक्ष्यों में static कीवर्ड द्वारा परिभाषित एरे भी हैं, यदि एक संदर्भ में तो यह होगा कि वह ऐंड hat() मेथड होना के उपयोग sṯैटिक कीवर्ड का उपयोग कर लेते हैं, तब भी एरे]$ ध्यान्रकरण के बाद भी संभाल, जो आपको समर्थन के लिए लीक आसंगतिक नहीं स हेंग :, इसलिए मेमोरी लीक की स्थिति उत्पन्न होती है:lore Added मेमोरी जगह को भी बढ़ाया जा सकता है, और मेमोरी छोड़ नहीं होती है, यह सा ामान्य घटना है। (gc_mem_caches() मेथड को कॉल करने से कुछ खाली मेमोरी रिलीज हो सकती है)
मानक
## सुझाव
हम सलाह देते हैं कि डेवलपर्स को नहीं चाहिए कि वे प्राथमिकता दें मेमोरी लीक को, क्योंकि यह बहुत कम होता है, अगर दुर्भाग्यपूर्ण रूप से कोई लीक होता है तो हम टेस्टिंग के माध्यम से उस कोड को ढूंढ़ सकते हैं जिससे लीक हुआ है, इससे हम समस्या को निश्चित कर सकते हैं। यदि डेवलपर्स लीक प्वाइंट नहीं ढूंढ़ पाते हैं, तो webman ने स्वयं का मॉनिटर सर्विस सही समय पर मेमोरी लीक हो रहे प्रोसेस को सुरक्षित रीस्टार्ट करने की सुविधा दी है, मेमोरी को वेबन किए गए कार्य करने के लिए मुक्त करने के लिए।

यदि आप मेमोरी लीक से बचना चाहते हैं, तो निम्नलिखित सुझाव का पालन कर सकते हैं।
1. `global`, `static` कीवर्ड के अर्रे का ज्यादा प्रयोग न करें, यदि आप करते हैं तो सुनिश्चित करें कि वे अनंत ही नहीं फैलते हैं
2. अनजाने क्लास के लिए, सिंगलटन का ज्यादा उपयोग न करें, नए कीवर्ड का उपयोग करके शुरू करें। यदि आपको सिंगलटन की आवश्यकता है, तो यह देखें कि क्या इसमें अनंत ही फैलने वाले अर्रे की गुणवत्ता है
